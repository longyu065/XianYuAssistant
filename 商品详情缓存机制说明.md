# 商品详情缓存机制说明

## 概述

为了避免频繁请求闲鱼API导致被风控，实现了商品详情的智能缓存机制。

## 缓存策略

### 1. 缓存时效

- **有效期**：24小时
- **存储位置**：数据库 `xianyu_goods_info` 表的 `detail_info` 字段
- **时间戳**：`updated_time` 字段记录最后更新时间

### 2. 缓存判断逻辑

```java
private boolean isDetailInfoFresh(String updatedTime) {
    // 解析更新时间
    LocalDateTime updateDateTime = LocalDateTime.parse(updatedTime, 
        DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss"));
    
    // 计算时间差
    Duration duration = Duration.between(updateDateTime, LocalDateTime.now());
    long hours = duration.toHours();
    
    // 24小时内认为是新鲜的
    return hours < 24;
}
```

## 获取流程

### 完整流程图

```
开始获取商品详情
    ↓
检查数据库是否有该商品
    ↓
是否有 detail_info？
    ├─ 否 → 调用API获取
    └─ 是 → 检查是否在24小时内
        ├─ 是 → 返回缓存（不调用API）
        └─ 否 → 调用API更新
            ↓
        API调用成功？
            ├─ 是 → 更新数据库并返回
            └─ 否 → 返回过期缓存（降级）
```

### 详细步骤

#### 步骤1：检查缓存

```java
// 从数据库获取商品信息
XianyuGoodsInfo cachedItem = goodsInfoService.getByXyGoodId(itemId);

// 检查是否有缓存的详情
if (cachedItem != null && cachedItem.getDetailInfo() != null) {
    // 检查缓存是否新鲜（24小时内）
    if (isDetailInfoFresh(cachedItem.getUpdatedTime())) {
        log.info("使用缓存的商品详情: itemId={}", itemId);
        return cachedItem.getDetailInfo();  // 直接返回缓存
    }
}
```

#### 步骤2：调用API获取

```java
// 获取Cookie
String cookiesStr = getCookieFromDb(cookieId);

// 调用闲鱼API
String detailJson = fetchDetailFromApi(itemId, cookiesStr);

if (detailJson != null) {
    // 更新数据库
    goodsInfoService.updateDetailInfo(itemId, detailJson);
    return detailJson;
}
```

#### 步骤3：降级处理

```java
// 如果API失败，但有过期的缓存，也返回它
if (cachedItem != null && cachedItem.getDetailInfo() != null) {
    log.info("返回过期的缓存详情: itemId={}", itemId);
    return cachedItem.getDetailInfo();
}
```

## 优势分析

### 1. 减少API调用

**场景示例：**
- 用户第一次查看商品详情：调用API（1次）
- 用户在24小时内再次查看：使用缓存（0次）
- 用户在24小时后查看：调用API更新（1次）

**节省比例：**
- 假设用户平均每天查看同一商品3次
- 无缓存：3次API调用
- 有缓存：1次API调用
- **节省率：66.7%**

### 2. 避免风控

**风控触发条件：**
- 短时间内大量请求同一接口
- 频繁请求商品详情

**缓存机制的保护：**
- 24小时内只调用1次API
- 大幅降低请求频率
- 有效避免触发风控

### 3. 提升响应速度

**性能对比：**
- API调用：500-1000ms
- 数据库查询：10-50ms
- **速度提升：10-100倍**

### 4. 降级保护

**场景：**
- API服务不可用
- Cookie失效
- 网络异常

**处理：**
- 返回过期的缓存数据
- 保证基本功能可用
- 提升用户体验

## 使用示例

### 示例1：首次获取详情

```bash
# 请求
curl -X POST "http://localhost:8080/api/items/detail" \
  -H "Content-Type: application/json" \
  -d '{"xyGoodId":"123456789","cookieId":"1"}'

# 日志
开始获取商品详情: itemId=123456789
调用闲鱼API获取商品详情: itemId=123456789
API获取商品详情成功: itemId=123456789, 详情长度=5432
商品详情已更新: xyGoodId=123456789

# 结果：调用API，更新数据库
```

### 示例2：24小时内再次获取

```bash
# 请求（同上）

# 日志
开始获取商品详情: itemId=123456789
使用缓存的商品详情: itemId=123456789, 缓存时间=2024-11-12 10:00:00
详情缓存检查: 更新时间=2024-11-12 10:00:00, 距今2小时, 是否新鲜=true

# 结果：使用缓存，不调用API
```

### 示例3：24小时后获取

```bash
# 请求（同上）

# 日志
开始获取商品详情: itemId=123456789
缓存的商品详情已过期，重新获取: itemId=123456789
调用闲鱼API获取商品详情: itemId=123456789
API获取商品详情成功: itemId=123456789, 详情长度=5432
商品详情已更新: xyGoodId=123456789

# 结果：缓存过期，调用API更新
```

### 示例4：API失败但有缓存

```bash
# 请求（同上）

# 日志
开始获取商品详情: itemId=123456789
缓存的商品详情已过期，重新获取: itemId=123456789
调用闲鱼API获取商品详情: itemId=123456789
API返回失败: FAIL_SYS_TOKEN_EMPTY::令牌为空
返回过期的缓存详情: itemId=123456789

# 结果：API失败，返回过期缓存（降级）
```

## 配置说明

### 缓存时效配置

当前缓存时效硬编码为24小时，如需修改：

```java
// 在 isDetailInfoFresh() 方法中修改
private boolean isDetailInfoFresh(String updatedTime) {
    // ...
    long hours = duration.toHours();
    
    // 修改这里的数值（单位：小时）
    return hours < 24;  // 改为其他值，如：12、48等
}
```

### 建议配置

- **高频访问场景**：12小时
- **正常场景**：24小时（默认）
- **低频访问场景**：48小时

## 监控建议

### 关键指标

1. **缓存命中率**
   - 计算公式：缓存命中次数 / 总请求次数
   - 目标值：> 70%

2. **API调用频率**
   - 监控每小时API调用次数
   - 告警阈值：根据业务量设定

3. **缓存过期率**
   - 计算公式：过期缓存使用次数 / 总请求次数
   - 目标值：< 10%

### 日志监控

关键日志关键词：
- `使用缓存的商品详情` - 缓存命中
- `缓存的商品详情已过期` - 缓存过期
- `返回过期的缓存详情` - 降级处理
- `API获取商品详情成功` - API调用成功

## 注意事项

1. **数据一致性**
   - 缓存期间商品信息可能发生变化
   - 如需实时数据，可手动清除缓存

2. **存储空间**
   - 详情信息较大（通常5-10KB）
   - 需定期清理过期商品数据

3. **并发控制**
   - 当前未实现并发控制
   - 高并发场景可能导致重复调用API

4. **缓存预热**
   - 可在刷新商品列表后批量获取详情
   - 提前填充缓存，提升用户体验

## 未来优化方向

1. **分布式缓存**
   - 使用Redis等缓存中间件
   - 提升性能和扩展性

2. **并发控制**
   - 实现分布式锁
   - 避免重复调用API

3. **缓存预热**
   - 后台任务定期更新热门商品详情
   - 提升缓存命中率

4. **智能过期**
   - 根据商品状态动态调整缓存时效
   - 在售商品：短时效
   - 已售出商品：长时效

## 总结

通过实现智能缓存机制，有效降低了API调用频率，避免了风控风险，同时提升了系统性能和用户体验。缓存策略简单有效，易于维护和扩展。
