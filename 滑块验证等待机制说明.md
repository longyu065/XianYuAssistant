# 滑块验证等待机制说明

## 问题背景

之前的实现中，当检测到需要滑块验证时，前端每5秒会重新请求一次 `/api/websocket/start`，导致后端不断抛出 `CaptchaRequiredException` 异常，产生大量重复的日志。

## 解决方案

实现了一个等待机制，当检测到需要验证时，会记录账号的等待状态，避免重复请求Token API。

### 核心机制

1. **等待状态记录**
   ```java
   // 记录正在等待验证的账号
   private final Map<Long, String> pendingCaptchaAccounts = new ConcurrentHashMap<>();
   
   // 记录验证URL的创建时间
   private final Map<Long, Long> captchaTimestamps = new ConcurrentHashMap<>();
   ```

2. **状态检查**
   - 在获取Token之前，先检查账号是否正在等待验证
   - 如果正在等待且未超时，直接返回之前的验证URL，不重复请求
   - 如果超时（5分钟），清除等待状态，允许重新请求

3. **状态清除**
   - 验证成功后（获取到Token），自动清除等待状态
   - 超时后（5分钟），自动清除等待状态
   - Token已存在且有效时，清除等待状态

## 工作流程

### 首次检测到验证

```
1. 前端请求 /api/websocket/start
   ↓
2. 后端调用 getAccessToken()
   ↓
3. 检查等待状态 → 无等待记录
   ↓
4. 请求Token API
   ↓
5. 检测到需要验证
   ↓
6. 记录等待状态：
   - pendingCaptchaAccounts.put(accountId, captchaUrl)
   - captchaTimestamps.put(accountId, currentTime)
   ↓
7. 抛出 CaptchaRequiredException
   ↓
8. 前端显示验证弹窗
```

### 后续重复请求

```
1. 前端5秒后再次请求 /api/websocket/start
   ↓
2. 后端调用 getAccessToken()
   ↓
3. 检查等待状态 → 发现正在等待
   ↓
4. 检查是否超时 → 未超时
   ↓
5. 直接抛出 CaptchaRequiredException（使用缓存的URL）
   ↓
6. 不会重复请求Token API ✅
   ↓
7. 日志只输出 debug 级别信息
```

### 验证完成

```
1. 用户完成滑块验证
   ↓
2. Cookie已更新（包含新的验证信息）
   ↓
3. 前端再次请求 /api/websocket/start
   ↓
4. 后端调用 getAccessToken()
   ↓
5. 检查等待状态 → 发现正在等待
   ↓
6. 检查数据库Token → 发现有效Token
   ↓
7. 清除等待状态
   ↓
8. 返回Token，连接成功 ✅
```

## 代码实现

### 检查等待状态

```java
// 0. 检查是否正在等待验证
if (pendingCaptchaAccounts.containsKey(accountId)) {
    Long timestamp = captchaTimestamps.get(accountId);
    if (timestamp != null && System.currentTimeMillis() - timestamp < CAPTCHA_TIMEOUT) {
        // 仍在等待验证，直接抛出异常，不重复请求
        String captchaUrl = pendingCaptchaAccounts.get(accountId);
        log.debug("【账号{}】正在等待滑块验证，跳过重复请求", accountId);
        throw new CaptchaRequiredException(captchaUrl);
    } else {
        // 验证超时，清除记录，允许重新请求
        log.info("【账号{}】验证超时，清除等待状态", accountId);
        pendingCaptchaAccounts.remove(accountId);
        captchaTimestamps.remove(accountId);
    }
}
```

### 记录等待状态

```java
if (needCaptcha) {
    // 提取滑块验证URL
    String captchaUrl = (String) dataMap.get("url");
    
    // 记录等待验证状态
    pendingCaptchaAccounts.put(accountId, captchaUrl);
    captchaTimestamps.put(accountId, System.currentTimeMillis());
    
    log.warn("【账号{}】检测到滑块验证，URL: {}", accountId, captchaUrl);
    
    // 抛出异常让用户手动处理
    throw new CaptchaRequiredException(captchaUrl);
}
```

### 清除等待状态

```java
// 获取到有效Token时
if (cookieEntity.getTokenExpireTime() > now) {
    // 清除等待验证状态（如果有）
    pendingCaptchaAccounts.remove(accountId);
    captchaTimestamps.remove(accountId);
    return cookieEntity.getWebsocketToken();
}
```

## 优势

### 1. 减少重复请求

**之前**：
- 每5秒请求一次Token API
- 每次都会触发验证检测
- 产生大量重复日志

**现在**：
- 首次检测到验证后记录状态
- 后续请求直接返回缓存的验证URL
- 不会重复请求Token API

### 2. 降低日志噪音

**之前的日志**：
```
2025-11-13 10:50:27 WARN  检测到滑块验证
2025-11-13 10:50:27 WARN  需要人工完成滑块验证
2025-11-13 10:50:27 WARN  启动WebSocket需要滑块验证
2025-11-13 10:50:27 WARN  需要滑块验证 [异常堆栈]
... 每5秒重复一次 ...
```

**现在的日志**：
```
2025-11-13 10:50:27 WARN  检测到滑块验证（首次）
2025-11-13 10:50:32 DEBUG 正在等待滑块验证，跳过重复请求
2025-11-13 10:50:37 DEBUG 正在等待滑块验证，跳过重复请求
... 只输出debug级别 ...
```

### 3. 避免频率限制

- 减少对Token API的请求频率
- 降低触发闲鱼频率限制的风险
- 更友好的服务器交互

## 超时机制

### 超时时间

```java
private static final long CAPTCHA_TIMEOUT = 5 * 60 * 1000; // 5分钟
```

### 超时处理

1. **为什么需要超时**
   - 用户可能关闭验证窗口
   - 验证URL可能失效
   - 需要重新获取新的验证URL

2. **超时后的行为**
   - 清除等待状态
   - 允许重新请求Token API
   - 获取新的验证URL

3. **超时日志**
   ```
   【账号1】验证超时，清除等待状态
   【账号1】开始获取新的accessToken...
   ```

## 前端配合

前端的定时检查机制保持不变：

```javascript
// 每5秒检查一次
setInterval(async () => {
    const response = await fetch(`${API_BASE}/start`, {
        method: 'POST',
        body: JSON.stringify({ xianyuAccountId: accountId })
    });
    
    const result = await response.json();
    
    if (result.code === 200) {
        // 验证成功，连接已建立
        closeCaptchaModal();
        showSuccess();
    } else if (result.code === 500 && result.data && result.data.needCaptcha) {
        // 仍需验证，继续等待（后端会返回缓存的URL）
        console.log('仍需验证，继续等待...');
    }
}, 5000);
```

## 注意事项

1. **线程安全**
   - 使用 `ConcurrentHashMap` 保证线程安全
   - 多个请求同时到达时不会出现竞态条件

2. **内存管理**
   - 验证成功后自动清除记录
   - 超时后自动清除记录
   - 不会造成内存泄漏

3. **日志级别**
   - 首次检测：WARN 级别
   - 重复请求：DEBUG 级别
   - 超时清除：INFO 级别

## 测试场景

### 场景1：正常验证流程

1. 启动连接 → 检测到验证 → 显示弹窗
2. 5秒后重试 → 跳过重复请求 → 继续等待
3. 10秒后重试 → 跳过重复请求 → 继续等待
4. 用户完成验证 → 获取到Token → 连接成功

**预期**：只有首次会请求Token API，后续都是返回缓存

### 场景2：验证超时

1. 启动连接 → 检测到验证 → 显示弹窗
2. 用户关闭弹窗，5分钟后再次尝试
3. 检测到超时 → 清除等待状态
4. 重新请求Token API → 获取新的验证URL

**预期**：超时后允许重新获取验证URL

### 场景3：手动输入Token

1. 启动连接 → 检测到验证
2. 用户手动输入Token
3. Token保存到数据库
4. 再次启动连接 → 使用数据库Token → 清除等待状态

**预期**：手动输入Token后，等待状态被清除

## 总结

通过实现等待机制，我们成功解决了：

- ✅ 避免重复请求Token API
- ✅ 减少日志噪音
- ✅ 降低触发频率限制的风险
- ✅ 提供更好的用户体验

同时保持了：

- ✅ 前端定时检查机制
- ✅ 自动检测验证完成
- ✅ 超时重试机制
