# 消息发送500错误排查指南

## 问题现象

发送消息时返回500错误：
```
{"headers":{"dt":"j","mid":"8441762954883749 0","sid":"..."},"code":500}
```

## 可能的原因

### 1. 用户ID格式问题

**问题**：`actualReceivers`中使用了错误的用户ID格式

**Python代码**：
```python
"actualReceivers": [
    f"{toid}@goofish",      # 接收方ID
    f"{self.myid}@goofish"  # 发送方ID（当前用户）
]
```

**Java实现**：
```java
actualReceivers.add(toId + "@goofish");
actualReceivers.add(senderUserId + "@goofish");  // 使用myUserId（从Cookie的unb字段获取）
```

**检查点**：
- `myUserId`是否正确设置（应该是Cookie中的unb字段）
- `toId`是否是正确的用户ID（不是accountId）

### 2. 会话ID格式问题

**问题**：cid格式不正确

**正确格式**：
- 输入：`3812882055015`（纯数字，不带后缀）
- 发送：`3812882055015@goofish`（自动添加后缀）

**检查点**：
- cid是否是从数据库`session_id`字段获取的
- cid是否已经包含了`@goofish`后缀（不应该包含）

### 3. 消息内容编码问题

**Python代码**：
```python
text = {
    "contentType": 1,
    "text": {
        "text": text
    }
}
text_base64 = str(base64.b64encode(json.dumps(text).encode('utf-8')), 'utf-8')
```

**Java实现**：
```java
Map<String, Object> textContent = new HashMap<>();
textContent.put("contentType", 1);
Map<String, String> textData = new HashMap<>();
textData.put("text", text);
textContent.put("text", textData);

String textJson = objectMapper.writeValueAsString(textContent);
String textBase64 = Base64.getEncoder().encodeToString(textJson.getBytes("UTF-8"));
```

**检查点**：
- JSON序列化是否正确
- Base64编码是否正确

## 排查步骤

### 步骤1：检查用户ID

```sql
-- 查询当前账号的用户ID（从Cookie表）
SELECT id, user_id, unb 
FROM xianyu_cookie 
WHERE id = 1;

-- 查询聊天消息中的用户ID
SELECT 
    session_id,
    sender_user_id,
    receiver_user_id,
    direction
FROM xianyu_chat_message
WHERE xianyu_account_id = 1
ORDER BY message_time DESC
LIMIT 5;
```

**验证**：
- Cookie表的`unb`字段应该与聊天消息中的`sender_user_id`或`receiver_user_id`匹配
- 如果是回复收到的消息（direction=2），toId应该使用`sender_user_id`

### 步骤2：检查消息格式

在日志中查看实际发送的消息内容：

```
【账号1】消息内容: {"lwp":"/r/MessageSend/sendByReceiverScope","headers":{"mid":"..."},"body":[...]}
```

**对比Python格式**：
```json
{
  "lwp": "/r/MessageSend/sendByReceiverScope",
  "headers": {
    "mid": "6551762954272987 0"
  },
  "body": [
    {
      "uuid": "-17629542729862",
      "cid": "55435931514@goofish",
      "conversationType": 1,
      "content": {
        "contentType": 101,
        "custom": {
          "type": 1,
          "data": "eyJjb250ZW50VHlwZSI6MSwidGV4dCI6eyJ0ZXh0IjoibmloYW8ifX0="
        }
      },
      "redPointPolicy": 0,
      "extension": {
        "extJson": "{}"
      },
      "ctx": {
        "appVersion": "1.0",
        "platform": "web"
      },
      "mtags": {},
      "msgReadStatusSetting": 1
    },
    {
      "actualReceivers": [
        "3553532632@goofish",
        "2218021801256@goofish"
      ]
    }
  ]
}
```

### 步骤3：验证Base64编码

**原始内容**：
```json
{"contentType":1,"text":{"text":"你好"}}
```

**Base64编码后**：
```
eyJjb250ZW50VHlwZSI6MSwidGV4dCI6eyJ0ZXh0Ijoi5L2g5aW9In19
```

**验证方法**：
```java
// 在代码中添加日志
log.info("【账号{}】原始消息内容: {}", accountId, textJson);
log.info("【账号{}】Base64编码后: {}", accountId, textBase64);
```

### 步骤4：检查WebSocket连接状态

```java
// 确认WebSocket已连接
if (!client.isConnected()) {
    log.error("WebSocket未连接");
    return false;
}

// 确认myUserId已设置
if (myUserId == null) {
    log.error("myUserId未设置，使用accountId: {}", accountId);
}
```

## 常见错误场景

### 场景1：使用了accountId而不是unb

**错误**：
```java
actualReceivers.add("1@goofish");  // accountId=1
```

**正确**：
```java
actualReceivers.add("2218021801256@goofish");  // unb字段的值
```

### 场景2：cid已经包含@goofish后缀

**错误**：
```java
String cid = "3812882055015@goofish";
messageBody.put("cid", cid + "@goofish");  // 结果：3812882055015@goofish@goofish
```

**正确**：
```java
String cid = "3812882055015";  // 不带后缀
messageBody.put("cid", cid + "@goofish");  // 结果：3812882055015@goofish
```

### 场景3：toId使用了错误的用户ID

**错误示例**：
```sql
-- 查询发送的消息（direction=1），但使用了sender_user_id
SELECT sender_user_id as toId  -- 错误：这是自己的ID
FROM xianyu_chat_message
WHERE direction = 1;
```

**正确示例**：
```sql
-- 查询收到的消息（direction=2），使用sender_user_id
SELECT sender_user_id as toId  -- 正确：这是对方的ID
FROM xianyu_chat_message
WHERE direction = 2;

-- 或者查询发送的消息（direction=1），使用receiver_user_id
SELECT receiver_user_id as toId  -- 正确：这是对方的ID
FROM xianyu_chat_message
WHERE direction = 1;
```

## 调试建议

### 1. 添加详细日志

在`XianyuWebSocketClient.sendMessage`方法中添加：

```java
log.info("【账号{}】=== 发送消息调试信息 ===", accountId);
log.info("【账号{}】输入参数 - cid: {}, toId: {}, text: {}", accountId, cid, toId, text);
log.info("【账号{}】当前用户ID - myUserId: {}, accountId: {}", accountId, myUserId, accountId);
log.info("【账号{}】实际发送者ID: {}", accountId, senderUserId);
log.info("【账号{}】actualReceivers: {}", accountId, actualReceivers);
log.info("【账号{}】完整消息体: {}", accountId, messageJson);
log.info("【账号{}】=== 调试信息结束 ===", accountId);
```

### 2. 对比Python日志

运行Python版本，查看实际发送的消息格式，与Java版本对比。

### 3. 使用Wireshark抓包

抓取WebSocket通信包，查看实际发送的数据格式。

### 4. 测试简化版本

先发送一个最简单的消息，确认基本流程正确：

```java
// 使用已知正确的参数测试
String testCid = "从成功的Python日志中复制";
String testToId = "从成功的Python日志中复制";
String testText = "test";
```

## 解决方案

### 方案1：确保myUserId正确设置

在`WebSocketServiceImpl.connectWebSocket`方法中：

```java
// 从Cookie中获取unb字段
Map<String, String> cookies = XianyuSignUtils.parseCookies(cookieStr);
String unb = cookies.get("unb");

// 设置到WebSocket客户端
client.setMyUserId(unb);

log.info("【账号{}】设置用户ID: {}", accountId, unb);
```

### 方案2：从数据库查询正确的参数

```sql
-- 查询最近收到的消息，获取正确的参数
SELECT 
    session_id as cid,
    sender_user_id as toId,
    content_text,
    raw_data
FROM xianyu_chat_message
WHERE xianyu_account_id = 1
  AND direction = 2  -- 收到的消息
ORDER BY message_time DESC
LIMIT 1;
```

### 方案3：验证消息格式

创建单元测试，验证消息格式是否正确：

```java
@Test
public void testMessageFormat() {
    // 构造消息
    Map<String, Object> textContent = new HashMap<>();
    textContent.put("contentType", 1);
    Map<String, String> textData = new HashMap<>();
    textData.put("text", "你好");
    textContent.put("text", textData);
    
    // 序列化
    String json = objectMapper.writeValueAsString(textContent);
    System.out.println("JSON: " + json);
    
    // Base64编码
    String base64 = Base64.getEncoder().encodeToString(json.getBytes("UTF-8"));
    System.out.println("Base64: " + base64);
    
    // 解码验证
    String decoded = new String(Base64.getDecoder().decode(base64), "UTF-8");
    System.out.println("Decoded: " + decoded);
    
    // 应该与原始JSON相同
    assertEquals(json, decoded);
}
```

## 成功标志

当消息发送成功时，应该看到：

1. **发送日志**：
```
【账号1】发送消息成功: cid=3812882055015, toId=3553532632, text=你好
```

2. **服务器响应**：
```
{"code":200,"headers":{...}}
```

3. **消息出现在聊天记录中**：
```sql
SELECT * FROM xianyu_chat_message 
WHERE content_text = '你好' 
AND direction = 1 
ORDER BY message_time DESC LIMIT 1;
```

## 参考资料

- Python代码：`XianyuAutoAsync.py` 的 `send_msg` 方法
- Web端示例：浏览器开发者工具中的WebSocket消息
- 数据库表：`xianyu_chat_message` 表结构
