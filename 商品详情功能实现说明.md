# 商品详情功能实现说明

## 功能概述

实现了商品详情的按需获取功能，将 `detail_info` 字段的填充逻辑移到 `/api/items/detail` 接口中，避免在刷新商品列表时频繁请求详情接口导致被风控。

## 实现方案

### 1. 数据流程

```
刷新商品列表 (/api/items/refresh)
    ↓
只保存基本信息（标题、价格、图片等）
    ↓
detail_info 字段为空
    ↓
需要查看详情时调用 (/api/items/detail)
    ↓
调用闲鱼API获取详情
    ↓
更新 detail_info 字段
```

### 2. API接口

#### 2.1 获取商品详情

**接口地址：** `POST /api/items/detail`

**请求参数：**
```json
{
  "xyGoodId": "123456789",      // 必填：闲鱼商品ID
  "cookieId": "default"         // 可选：Cookie ID，提供时会更新详情
}
```

**功能说明：**
- 如果不提供 `cookieId`：只返回数据库中已有的商品信息
- 如果提供 `cookieId`：调用闲鱼API获取最新详情并更新数据库

### 3. 详情获取流程

#### 3.1 首选方式：通过闲鱼API

调用 `mtop.taobao.idle.pc.detail` 接口获取商品详情：

```java
// 构建请求数据
Map<String, Object> dataMap = new HashMap<>();
dataMap.put("itemId", itemId);

// 调用API
String response = XianyuApiUtils.callApi(
    "mtop.taobao.idle.pc.detail",
    dataMap,
    cookiesStr
);
```

#### 3.2 响应处理

```java
// 检查响应是否成功
if (XianyuApiUtils.isSuccess(response)) {
    // 提取data字段
    Map<String, Object> data = XianyuApiUtils.extractData(response);
    
    // 转换为JSON字符串保存
    String detailJson = objectMapper.writeValueAsString(data);
    
    // 更新数据库
    goodsInfoService.updateDetailInfo(xyGoodId, detailJson);
}
```

### 4. 代码实现

#### 4.1 修改的文件

1. **ItemDetailReqDTO.java** - 添加 `cookieId` 字段
2. **GoodsInfoService.java** - 添加 `updateDetailInfo()` 方法
3. **GoodsInfoServiceImpl.java** - 实现 `updateDetailInfo()` 方法
4. **ItemServiceImpl.java** - 实现详情获取逻辑（含缓存机制）

#### 4.2 核心方法

**fetchItemDetailFromApi()** - 从API获取商品详情（主入口）
```java
private String fetchItemDetailFromApi(String itemId, String cookieId) {
    // 1. 检查缓存（24小时内的详情不重复获取）
    XianyuGoodsInfo cachedItem = goodsInfoService.getByXyGoodId(itemId);
    if (cachedItem != null && isDetailInfoFresh(cachedItem.getUpdatedTime())) {
        return cachedItem.getDetailInfo();  // 返回缓存
    }
    
    // 2. 获取Cookie
    String cookiesStr = getCookieFromDb(cookieId);
    
    // 3. 首选：通过API获取
    String detailJson = fetchDetailFromApi(itemId, cookiesStr);
    
    // 4. 备选：通过浏览器访问（暂未实现）
    if (detailJson == null) {
        // 可以在这里实现浏览器访问逻辑
    }
    
    return detailJson;
}
```

**fetchDetailFromApi()** - 通过API获取详情
```java
private String fetchDetailFromApi(String itemId, String cookiesStr) {
    // 1. 构建请求数据
    Map<String, Object> dataMap = new HashMap<>();
    dataMap.put("itemId", itemId);
    
    // 2. 调用API
    String response = XianyuApiUtils.callApi(
        "mtop.taobao.idle.pc.detail",
        dataMap,
        cookiesStr
    );
    
    // 3. 检查响应
    if (!XianyuApiUtils.isSuccess(response)) {
        return null;
    }
    
    // 4. 提取data字段
    Map<String, Object> data = XianyuApiUtils.extractData(response);
    
    // 5. 返回JSON字符串
    return objectMapper.writeValueAsString(data);
}
```

**isDetailInfoFresh()** - 检查缓存是否新鲜
```java
private boolean isDetailInfoFresh(String updatedTime) {
    // 解析更新时间
    LocalDateTime updateDateTime = LocalDateTime.parse(updatedTime, 
        DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss"));
    
    // 计算时间差
    Duration duration = Duration.between(updateDateTime, LocalDateTime.now());
    long hours = duration.toHours();
    
    // 24小时内认为是新鲜的
    return hours < 24;
}
```

**updateDetailInfo()** - 更新数据库中的详情信息
```java
public boolean updateDetailInfo(String xyGoodId, String detailInfo) {
    // 1. 查询商品
    XianyuGoodsInfo existingGoods = goodsInfoMapper.selectOne(
        new LambdaQueryWrapper<XianyuGoodsInfo>()
            .eq(XianyuGoodsInfo::getXyGoodId, xyGoodId)
    );
    
    // 2. 更新详情
    existingGoods.setDetailInfo(detailInfo);
    existingGoods.setUpdatedTime(getCurrentTimeString());
    
    // 3. 保存到数据库
    return goodsInfoMapper.updateById(existingGoods) > 0;
}
```

### 5. 使用示例

#### 5.1 只获取基本信息（不更新详情）

```bash
curl -X POST "http://localhost:8080/api/items/detail" \
  -H "Content-Type: application/json" \
  -d '{"xyGoodId":"123456789"}'
```

#### 5.2 获取并更新详情信息

```bash
curl -X POST "http://localhost:8080/api/items/detail" \
  -H "Content-Type: application/json" \
  -d '{"xyGoodId":"123456789","cookieId":"default"}'
```

### 6. 优势

1. **避免风控**：刷新商品列表时不请求详情，只在需要时才获取
2. **提高性能**：减少不必要的API调用
3. **灵活性**：可以选择是否更新详情
4. **缓存机制**：详情信息保存在数据库中，24小时内不重复获取
5. **智能缓存**：自动检查缓存新鲜度，过期自动更新
6. **降级策略**：API失败时返回缓存的详情（即使过期）

### 7. 注意事项

1. **Cookie有效性**：确保提供的Cookie是有效的
2. **请求频率**：建议在查看详情时才调用，避免频繁请求
3. **错误处理**：即使获取详情失败，也会返回数据库中的基本信息
4. **数据更新**：每次成功获取详情都会更新 `detail_info` 字段和 `updated_time` 字段
5. **缓存时效**：详情缓存有效期为24小时，过期后会自动重新获取
6. **降级处理**：如果API获取失败且有过期缓存，会返回过期的缓存数据

### 8. 测试

使用提供的测试脚本：
```bash
测试商品详情API.bat
```

输入商品ID后，会依次测试：
1. 获取商品详情（不更新详情信息）
2. 获取商品详情（同时更新详情信息）

## 总结

通过将详情获取逻辑从刷新接口中分离出来，实现了按需获取商品详情的功能，有效避免了因频繁请求而被风控的问题。同时保持了良好的用户体验，用户可以在需要时快速获取商品详情。
